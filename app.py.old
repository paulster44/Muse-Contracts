# app.py
import os
import datetime
import logging
import math
from flask import Flask, render_template, request, redirect, url_for, flash, session, make_response
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from flask_bcrypt import Bcrypt
from dotenv import load_dotenv
from flask_weasyprint import HTML # Assuming local WeasyPrint works now
from models import db, User, Contract, SideMusician
from sqlalchemy.exc import IntegrityError
from flask_wtf import FlaskForm
from wtforms import StringField, DateField, TimeField, FloatField, SelectField, SubmitField, IntegerField, BooleanField
from wtforms.validators import DataRequired, Length, Optional, NumberRange, ValidationError

load_dotenv()
app = Flask(__name__, instance_relative_config=True)

# --- Load Configuration ---
try: app.config.from_object('config')
except ImportError: app.logger.error("FATAL: config.py not found."); exit()
except Exception as e: app.logger.error(f"FATAL: Error loading config.py: {e}"); exit()
try:
    if not os.path.exists(app.instance_path): os.makedirs(app.instance_path)
except OSError: app.logger.error("Could not create instance folder!")

# --- Logging Setup ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s:%(name)s:%(message)s')
log_level = logging.DEBUG if app.config.get('DEBUG') else logging.INFO
app.logger.setLevel(log_level)
if app.config.get('SECRET_KEY', '').startswith('fallback') or not app.config.get('SECRET_KEY'): app.logger.critical("CRITICAL: SECRET_KEY not set/fallback!")

# --- Initialize Flask Extensions ---
try: db.init_app(app); bcrypt = Bcrypt(app); login_manager = LoginManager(app)
except Exception as e: app.logger.critical(f"Failed init extensions: {e}", exc_info=True)
login_manager.login_view = 'login'; login_manager.login_message_category = 'info'

# --- Constants (Loaded via config.py) ---
PRINCIPAL_INSTRUMENTS = app.config.get('PRINCIPAL_INSTRUMENTS', [])
CARTAGE_INSTRUMENTS_STD = app.config.get('CARTAGE_INSTRUMENTS_STD', [])
CARTAGE_INSTRUMENTS_SB = app.config.get('CARTAGE_INSTRUMENTS_SB', [])

# --- FORMS ---
class ContractStep1Form(FlaskForm):
    engagement_date = DateField('Engagement Date', validators=[DataRequired()])
    start_time = TimeField('Start Time', validators=[DataRequired()], format='%H:%M')
    end_time = TimeField('End Time', validators=[DataRequired()], format='%H:%M')
    leader_name = StringField('Leader/Employer Name', validators=[DataRequired(), Length(max=150)])
    leader_card_no = StringField('Leader AFM Card No.', validators=[Optional(), Length(max=50)])
    leader_address = StringField('Leader/Employer Address', validators=[DataRequired(), Length(max=250)])
    leader_phone = StringField('Leader/Employer Phone', validators=[DataRequired(), Length(max=30)])
    leader_ssn_ein = StringField('Leader SSN or EIN', validators=[Optional(), Length(max=50)])
    band_name = StringField('Name of Band/Group', validators=[Optional(), Length(max=150)])
    venue_name = StringField('Place of Engagement (Venue/Room)', validators=[DataRequired(), Length(max=200)])
    location_borough = SelectField('Location (Borough/Area)', choices=[('', '-- Choose --'),('NYC', 'NYC (Manhattan)'), ('BKLYN', 'Brooklyn'), ('QNS', 'Queens'), ('BX', 'Bronx'), ('SI', 'Staten Island'), ('NAS_SUF', 'Nassau/Suffolk'), ('OOT', 'Out of Town')], validators=[DataRequired(message="Please select a location.")])
    engagement_type = StringField('Type of Engagement', validators=[DataRequired(), Length(max=200)], render_kw={"placeholder": "e.g., Wedding, Concert"})
    pre_heat_hours = FloatField('Pre-Heat Hours', validators=[Optional(), NumberRange(min=0, message="Hours must be non-negative.")])
    save_draft = SubmitField('Save Draft & Exit')
    submit_next = SubmitField('Save and Continue »')

class ContractStep2Form(FlaskForm):
    num_musicians = IntegerField('Total Number of Musicians (incl. Leader)', validators=[DataRequired(), NumberRange(min=1)], default=1)
    actual_hours_engagement = FloatField('Actual Paid Hours of Engagement', validators=[DataRequired(message="Engagement hours required."), NumberRange(min=0.1)])
    has_rehearsal = BooleanField('Is there a Rehearsal?')
    actual_hours_rehearsal = FloatField('Actual Paid Hours of Rehearsal', validators=[Optional(), NumberRange(min=0.1)])
    is_recorded = BooleanField('Will performance be Recorded/Reproduced/Transmitted?')
    leader_is_incorporated = BooleanField('Is the Leader/Employer signing as an incorporated entity?')
    save_draft = SubmitField('Save Draft & Exit')
    submit_view = SubmitField('Save Step 2 & View »')
    def validate_actual_hours_rehearsal(form, field):
        if form.has_rehearsal.data and (field.data is None or field.data <= 0):
            raise ValidationError('Rehearsal hours required & positive if checked.')

# --- User Loader ---
@login_manager.user_loader
def load_user(user_id):
    if user_id is None or not user_id.isdigit(): return None
    try: return User.query.get(int(user_id))
    except Exception as e: app.logger.error(f"Error loading user {user_id}: {e}", exc_info=True); return None

# --- Context Processor ---
@app.context_processor
def inject_now(): return {'now': datetime.datetime.utcnow()}

# --- Helper Functions ---
def parse_time_safe(time_str): /* ... */
def parse_date_safe(date_str): /* ... */
def parse_float_safe(float_str): /* ... */
def is_principal(instrument_string, scale_config): /* ... */
def get_cartage_fee(instrument_string, has_cartage_flag, scale_config): /* ... */
# --- Calculation Helper Function ---
def calculate_contract_totals(contract): /* ... Calculation logic as previously provided ... */
# (Include the full code for helpers and calculate_contract_totals here from the previous complete app.py)
# --- IMPORTANT: Paste the full helper and calculation code here ---
# --- For brevity, I'm omitting them, but ensure they are present in your actual file ---
# --- (Code identical to the last full app.py version for these functions) ---
# --- Routes ---

@app.route('/')
@login_required
def dashboard():
    try: user_contracts = Contract.query.filter_by(user_id=current_user.id).order_by(Contract.last_saved_at.desc()).all(); return render_template('dashboard.html', contracts=user_contracts)
    except Exception as e: app.logger.error(f"Dashboard error user {current_user.email}: {e}", exc_info=True); flash('Could not load dashboard.', 'danger'); return redirect(url_for('login'))

@app.route('/register', methods=['GET', 'POST'])
def register():
    # (Remains the same)
    if current_user.is_authenticated: return redirect(url_for('dashboard'))
    if request.method == 'POST':
        email = request.form.get('email', '').strip(); password = request.form.get('password')
        if not email or not password: flash('Email/password required.', 'danger'); return render_template('register.html')
        if '@' not in email or '.' not in email.split('@')[-1]: flash('Invalid email.', 'danger'); return render_template('register.html')
        if User.query.filter_by(email=email).first(): flash('Email already registered.', 'warning'); return render_template('register.html')
        try: new_user = User(email=email); new_user.set_password(password); db.session.add(new_user); db.session.commit(); login_user(new_user); flash('Registration successful!', 'success'); app.logger.info(f"New user: {email}"); return redirect(url_for('dashboard'))
        except IntegrityError: db.session.rollback(); flash('Email registered (DB).', 'warning'); app.logger.warning(f"Reg IntegrityError: {email}"); return render_template('register.html')
        except Exception as e: db.session.rollback(); flash('Registration error.', 'danger'); app.logger.error(f"Reg error: {e}", exc_info=True); return render_template('register.html')
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    # (Remains the same - Ensure decorator @app.route('/login',...) is present!)
    if current_user.is_authenticated: return redirect(url_for('dashboard'))
    if request.method == 'POST':
        email = request.form.get('email', '').strip(); password = request.form.get('password')
        if not email or not password: flash('Email/password required.', 'danger'); return render_template('login.html')
        user = User.query.filter_by(email=email).first()
        if user and user.check_password(password):
            login_user(user, remember=request.form.get('remember')); flash('Login successful!', 'success'); app.logger.info(f"User logged in: {email}")
            next_page = request.args.get('next');
            if next_page and (next_page.startswith('/') or next_page.startswith(request.host_url)): return redirect(next_page)
            else: return redirect(url_for('dashboard'))
        else: flash('Login failed. Check credentials.', 'danger'); app.logger.warning(f"Failed login: {email}"); return render_template('login.html')
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    # (Remains the same)
    if current_user.is_authenticated: app.logger.info(f"User logged out: {current_user.email}"); logout_user(); flash('Logged out.', 'success')
    else: app.logger.warning("Logout route by non-auth user.")
    return redirect(url_for('login'))

# --- Contract Creation/Editing Steps ---

# >>>>> ENSURE THIS FUNCTION AND DECORATOR EXIST <<<<<
@app.route('/contract/new', methods=['GET'], endpoint='new_contract_route') # Explicit endpoint name
@login_required
def new_contract():
    """Starts a new contract draft and redirects to the first step."""
    try:
        new_draft = Contract(user_id=current_user.id, status='draft')
        db.session.add(new_draft); db.session.commit()
        flash('New draft contract started.', 'info'); app.logger.info(f"User {current_user.email} started draft {new_draft.id}")
        return redirect(url_for('create_contract_step', contract_id=new_draft.id, step_num=1))
    except Exception as e:
        db.session.rollback(); flash('Failed start new draft.', 'danger'); app.logger.error(f"Error new draft {current_user.email}: {e}", exc_info=True)
        return redirect(url_for('dashboard'))
# >>>>> END new_contract FUNCTION <<<<<


@app.route('/contract/create/<int:contract_id>/step/<int:step_num>', methods=['GET', 'POST'])
@login_required
def create_contract_step(contract_id, step_num):
    # (Logic using WTForms for validation as provided in previous 'full file' response)
    # ... Ensure the Step 1 and Step 2 POST handlers call calculate_contract_totals ...
    # ... Ensure the GET handler passes form and musicians_json correctly ...
    # --- PASTE THE FULL create_contract_step function from the previous complete app.py here ---
    # --- For brevity, omitting the full function again, but ensure it's the latest version ---
    # --- IMPORTANT: Make sure the 'if errors:' blocks have correct indentation ---
    pass # Replace with full function content

@app.route('/contract/view/<int:contract_id>')
@login_required
def view_contract(contract_id):
    # (Remains the same)
    try: contract = db.session.get(Contract, contract_id);
    except Exception as e: app.logger.error(f"Error fetching contract {contract_id} for view: {e}", exc_info=True); flash('Error loading contract.', 'danger'); return redirect(url_for('dashboard'))
    if not contract or contract.user_id != current_user.id: flash('Contract not found/access denied.', 'danger'); return redirect(url_for('dashboard'))
    musicians = contract.side_musicians.order_by(SideMusician.id).all()
    return render_template('view_contract.html', contract=contract, musicians=musicians)

# --- Contract Action Routes (Remain the same) ---
@app.route('/contract/delete/<int:contract_id>', methods=['POST'])
@login_required
def delete_contract(contract_id): # ... delete logic ...
@app.route('/contract/reopen/<int:contract_id>', methods=['POST'])
@login_required
def reopen_contract(contract_id): # ... reopen logic ...
@app.route('/contract/finalize/<int:contract_id>', methods=['POST'])
@login_required
def finalize_contract(contract_id): # ... finalize logic ...

# --- PDF Generation Route (UNCOMMENTED) ---
@app.route('/contract/pdf/<int:contract_id>')
@login_required
def download_contract_pdf(contract_id):
    # (PDF generation logic remains the same)
    try:
        contract = db.session.get(Contract, contract_id)
        if not contract or contract.user_id != current_user.id: flash('Contract not found or access denied.', 'danger'); return redirect(url_for('dashboard'))
        musicians = contract.side_musicians.order_by(SideMusician.id).all()
        scale_config = app.config.get('SCALES', {}).get(contract.applicable_local, {}).get(contract.applicable_scale)
        pension_rate_config = scale_config.get('PENSION_RATE', 0.0) if scale_config else 0.0
        html = render_template('contract_pdf.html', contract=contract, musicians=musicians, pension_rate_percent=pension_rate_config * 100)
        html_obj = HTML(string=html, base_url=request.base_url); pdf = html_obj.write_pdf()
        response = make_response(pdf); response.headers['Content-Type'] = 'application/pdf'
        filename = f"AFM802_Contract_{contract.id}_{contract.engagement_date or 'nodate'}.pdf"
        response.headers['Content-Disposition'] = f'inline; filename="{filename}"'
        app.logger.info(f"User {current_user.email} generated PDF for contract {contract_id}"); return response
    except NameError as ne: app.logger.error(f"PDF Gen Error - Missing Import: {ne}", exc_info=True); flash('PDF generation requires WeasyPrint (check imports).', 'danger'); return redirect(url_for('view_contract', contract_id=contract_id))
    except Exception as e: app.logger.error(f"Error generating PDF for {contract_id}: {e}", exc_info=True); flash('Error generating PDF.', 'danger'); return redirect(url_for('view_contract', contract_id=contract_id))

# --- Error Handlers (Remain the same) ---
@app.errorhandler(404) # ... 404 handler ...
@app.errorhandler(500) # ... 500 handler ...
@app.errorhandler(403) # ... 403 handler ...
@app.errorhandler(401) # ... 401 handler ...

# --- Database Initialization (Remains the same) ---
def initialize_database(): # ... db init logic ...
with app.app_context(): initialize_database()

# --- Main Execution Block (Remains the same) ---
if __name__ == '__main__': # ... app.run logic ...
